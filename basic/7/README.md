# 排序算法

## 经典排序算法的分类（按照时间复杂度）

- O(n^2) : 冒泡 插入 选择  这三个最好的就是 插入排序，速度最快。

- O(nlogn) : 希尔排序 快排 并归 堆排序（堆排序放到了堆那里来说明，这里就不谈了）

- O(n) : 桶 计数 基数

## 重要指标

- 稳定性 ： 相同的数字 排序前后时候发生变化 ，非常重要，通常我们需要相同的排序的时候不动他们，还是按照以前的顺序。

- 时间复杂度： 平均的 最好的 最坏的 对于比较小量的也要注意它的常数低次项式 以及所有的参数，因为数量级小，所以要注意这些

- 样本的排序度 也会对最后的结果产生很大的影响

- 是否使用了空间O(1) 是否开辟了额外的空间

- 交换的次数 比较的次数（只对于比较合交换的算法）

## 冒泡

```go

for i := 0 ; i < n ; i++ {
	for j := 0; j < n-i-1;j++ {
		if a[j] > a[j+1] {
			a[j],a[j+1] = a[j+1],a[j] 每次都是跟相邻的数据进行交换
		}
	}
}
```

```go

//改进
L:
for i := 0 ; i < n ; i++ {
	b := false
	for j := 0; j < n-i-1;j++ {
		if a[j] > a[j+1] {
			a[j],a[j+1] = a[j+1],a[j] 每次都是跟相邻的数据进行交换
			b = true
		}
		if !b {
		    break L	 // 这样就可以确保如果已经排序完成了继续排序的尴尬
		}
	}

```
优化的一点就是 判断 这次冒泡的过程中是否有过换位，如果这一次整个过程中都没有换位，可以证明已经结束了，直接break出来即可。

## 选择排序

```go
for i := 0;i < len(x) -1;i++ {
	min := i
	for j := i+1;j < len(x);j++{
		if x[min] > x[j]{
			min = j // 找到最小值的索引
		}
	}
	x[min],x[i] = x[i],x[min] //然后 让 此时的 i这个值跟 min调换位置，这样就成功的把 min加到了队尾
}
```

因为选择排序，在前面拍好的序列后加上后面最小的那个数字，所以 每次找到的最小，如果是一样的话 这些最小就会跟之前 按照相反的方向排列
故 并不稳定。 当然时间复杂度也是 n ^2 空间复杂度依然是1 因为没有其它的空间占用

## 插入排序

```go
for i := 1;i < len(x);i++ {
	value := x[i]
	for j := i-1;j >=0;j-- {
		if x[j] > value {
			x[j+1] = x[j] // 这是为了 往后转移
		}else{
			break //这是为了确保j刚好是在 插入的那个位置
		}
	}
	x[j+1] = value //在这个空位置 插入即可。
}

```

因为 插入排序是比值，如果是一样大的值，那么就不会插到这个位置，只会不动，所以说是 稳定的。 当然 空间复杂度也是1


## 为什么 插入排序和冒泡法时间复杂度都是 n^2 时间为什么不一样

答案： 因为 冒泡法需要 x[i],x[i+1] = x[j+1],x[j] 虽然go可以这么写 但是 这其实是3个步骤 ，但是插入排序只需要 x[j+1] = x[j]这是一个步骤
所以理论上 插入排序要比冒泡法 快3倍以上。或者是更快。

## 希尔排序

希尔排序是另一种 插入排序 它的平均时间复杂度是nlogn 这个log 取决于把每一份分成了多少。

## 并归排序
中心思想就是 分治，它是将所有的数据一点一点的分为一半一半，然后直到分成了一个一个，再合并 合并的时候就是分开的反向，然后就
一步一步的向上合并就ok了。

举个例子：

1，543，33，55，3，55，23，55，3

1 543 33 55  和 3 55 23 55 3

1 543和 33 55 和 3 55 和 23 55 3

1和543 和 33和55 和 3 和55 和 23 和55 3

1和543 和 33和55 和 3 和55 和 23 和55和3

现在开始合并了

1 543 和 33 55 和 3 55 和 3 23 55

1 33 55 543 和 3 3 23 55 55

 结局是： 1 3 3 23 33 55 55 55 543

 这就是整个的过程，先分治然后分别的合并然后最后全部排列后再合并。


## 快速排序
