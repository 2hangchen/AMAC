# 动态规划

动态规划，英文是：Dynamic Programming. 动态规划是和递归一样，是算法思想中最重要的思想之一，是跟递归一样重要甚至更重要的算法思想理念。
就跟很多著名的算法一样，例如跳表，动态规划也是一种用空间换时间的方法。

动态规划，使用多维数组来实现功能，使用的方式是，例如说二维数组，那么第一个就是第几步骤第二个就会在某一步骤所造成的后果（累计的后果），他们的值可以没有意义，例如背包问题，他们的值就是使用1 0 来代替，但是有的地方这个值就是代表了实际的意义。一般来说这个值代表的就是第三个变量。比如说背包问题的升级版 --- 引入加权的背包问题，比如说装入的东西是有价值的，那么这个价值就是使用这个值来确定的，当然这个值也是从第一部到这一步的总和。


“一个模型三个特征”理论讲解 什么样的问题适合用动态规划来解决呢?换句话说，动态规划能解决的问题有什么规律可循呢?实际上，动态规划作为一个非常成熟的算法思想，很多人对此已
经做了非常全面的总结。我把这部分理论总结为“一个模型三个特征”。 首先，我们来看，什么是“一个模型”?它指的是动态规划适合解决的问题的模型。我把这个模型定义为“多阶段决策最优解模型”。下面我具体来给你讲讲。
我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组 决策序列，能够产生最终期望求解的最优值。
现在，我们再来看，什么是“三个特征”?它们分别是最优子结构、无后效性和重复子问题。这三个概念比较抽象，我来逐一详细解释一下。

1. 最优子结构最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到 我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

2. 无后效性无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义 是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后 效性。

3. 重复子问题 这个概念比较好理解。前面一节，我已经多次提过。如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

动态规划最重要的做法就是第一看最后一步，第二看子问题，一般情况下从后往前推，贪心算法一般来说就是从前往后走，这也是贪心和DP做法很不一样的地方之一。
里面的所谓子问题，并不是说把解题思路分开 然后其中一个连着一个像链表一样的一个一个的node，子问题是指的是：从后往前，每次都解决一步，然后剩余的就叫做子问题。


## 背包问题-动态规划解法

有一个背包能承重W kg 然后我们这里有一些物品N个他们的重量分别是数组a的各个v，求在不超重的情况下能放进去的最大的重量。
背包问题的解决方法是我们将每个状态做成一个数组，然后每个状态的不同的内容视为数组的内容，这个时候我们需要一个矩阵
其中x是表示的每一次阶段，y表示每个阶段中的可能值。当走到最后一个步骤的时候我们就会发现不同的值，这些个值其实就是
最后的结局的不同解，那么我们只需要取最后一个，就是不超重情况下的最大值。[看代码](./1.go)

这里要注意的就三点 第一我们把这个过程分为一个一个的阶段，并且上一个阶段对下一个阶段有影响，第二下一部的走法，要严格按照上一步的走法
第三要从结果中能推出来最后的结局。

## 什么问题适合用动态规划来做呢？

`一个模型三个特征` 一个模型:我们用来解决最优解的这种问题，比如最省钱，装的最多，这种问题，然后最重要的一点就是这个模型可以把整个
算法的过程分为一个阶段一个阶段的这种形式，就是可以分级.

最优子结构:通过子问题的最优解来推断出整个问题的最优解，并且后面的阶段的状态可以用前面状态来
推出.

无后效性:我们关注后面的状态的时候只需要关注前一个的状态即可，至于怎么达到这个状态的不用管啊

重复子问题:也就是说相同的过程，应该会执行很多遍，但是这里不是用的递归，用的是for循环。

其实写成代码有这种形式，首先就是有一个大的for这个for是为了分级，然后for里面又有几个for这几个for是为了处理每一个层的具体事件，
然后还需要有一个status状态结构，例如一个status状态数组来记录每一层的状态。然后还需要有一个for循环，这个for循环是将子问题解出来的
问题推算出整个算法的问题的这个过程，所以总结一下就有这么几个过程

1. for + 内部的for
2. status数组
3. 上面for的下面再来一个for 这么算算最少要3个for才可以了。

## 如何快速发现这个问题是否可以使用DP

如果你发现一个问题可以使用递归回溯，那么它八成也可以使用DP

还有一般回溯的话就是多叉树，但是你会发现有很多重复的值，这个时候我们也可以借助一个哈希表，然后判断这些节点是否已经有了，如果有了那就不用再遍历了，直接回溯就ok了。那么这个时候你就要想了这种有很多重复值的是否可以使用动态规划，因为一般这个时候就可以使用动态规划了。
而且动态规划一般可以画图，也就是画出一个矩阵，通常x代表的能分成多少阶段而y就代表了每个阶段大概有多种可能性。然后看里面的值，这个值就代表了不同的含义。

## 动态规划的两种方法

- 动态转移表法
通过画出一个二维的数组，然后分析每一步的动作，然后翻译成代码即可。 其实就是for + 动态转移方程
- 动态转移方程
通过某个特定的方程，使用递归，然后实现动态规划。那么其实看起来这种动态规划其实就是**回溯+去重**

其实可以说 动态转移表法用的for循环代替了动态转移方程法的递归。更加节省空间。
