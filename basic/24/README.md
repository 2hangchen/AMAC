# 递归树

递归树的一大用途就是利用递归树来分析递归算法的时间复杂度。所谓递归树，也就是说你的递归算法被实际分解，真实的样子
其实就是一棵树，有可能是二叉树，大多数情况下可能就是多叉树，所以这种递归所产生的实际构造的树叫做递归形成的树结构 --- 递归树

将递归的过程用递归树的方式画出来有利于去构想递归算法以及跳出的条件，而且可以按照层来估算出时间复杂度。例如斐波那契数列的求解就是
一个二叉树的求解过程。

这种树也不是一种数据结构，它的目的就是将递归给化成真实的样子，举几个例子
## 斐波那契数列

真实的样子是一个满二叉树

## 快速排序

真实的样子是一个二叉树，应该是不满（因为两边不一定都是相同的嘛，所以是满二叉树的几率几乎是很小了）

## 归并排序

归并就是将数据分成一般，然后分到最后开始merge其实是边分边merge但是分在途中不是没有值一直还得往下分吗，所以它的真实的
样子就是一个满二叉树

```go
                                            Merge(n)
                            Merge(n/2)                    Merge(n/2)
                  Merge(n/2/2)  Merge(n/2/2)    Merge(n/2/2)          Merge(n/2/2)
                1     2        4       7       89     90             100  120

            // 归并的话需要先分然后再merge 为什么快排不用呢，人家直接就排好了，不用merge的这个过程了，所以它就分就完事儿了。


```
## 说一下递归的执行顺序

如果现在把递归画成树，比如说背包问题吧。那么肯定就是一个二叉树，那么我们给递归设置返回条件，每次返回就是一次向上一层的回溯。只要执行完了就会向上一层次回溯。这样的话就会把所有的数据全部枚举完毕。那么回溯只能回溯到上一层吗，非也，深度优先搜索中，如果是图的深度优先搜索，可以回溯到任意的顶点中，也就是返回到任意的顶点中。
