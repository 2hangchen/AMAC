# hash table
> 中文叫做散列表或者是哈希表

go 语言中的map用到的就是hash table的思想，思想本身就是映射，一个萝卜一个坑，可以快速找到我们要找的内容，并且和数组不同我们可以指定不同的k，
在数组中我们只能是数但是在哈希表中我们可以用字符串等等数据来指定k。

hash表是使用k通过哈希函数然后对应相应数组中的下表然后再通过下表找到数据的过程，所以说查找的时间复杂度才是O(1)
所以说底层的数据还是数组，只不过我们这里的k可以使任何的数据然后这个任何数据通过某种函数转化为数组的下标。这些下标和key值是一一对应的。

所以说白了 计算机里的数据结构最最最根本的就两种 1 数组 2 指针对象

利用数组的 比如 1 数组 2 切片 3 栈 4 队列 5 哈希表 。利用指针的 1 链表 跳表 树 图 ...

所以说在哈希表中找到k和底层数组下标的这个函数就至关重要，因为除了这个就是数组了嘛，对吧，所以说重点就是哈希函数（映射函数）
## hash 函数

大概就是这样的  `散列值 = Hash(key)` 也就是说这个函数就是key和数组下标的转换，这种函数有三点要注意

1. 散列值一定是非负整数 这一点也容易理解，如果不是整数你也没办法再数组中找到它的位置

2. 如果 key1 == key2 那么 hash(key1)  == hash(key2)

3. 如果key1 != key2 那么 hash(key1) != hash(key2)

前面两点都容易实现，也没什么可探讨的，但是第三点不容易，因为你计算出的值很不一定，很有可能key不同但是结果是一眼的。
目前的MD5或者等等算法也不能避免出现这种 “散列冲突” 就是key不一样但是非常有可能计算出的结果是一样的。
举个例子 你使用一种算法 那么key相同 就跟路是一样的走的过程肯定是一样的嘛，但是你走不同的小路 有可能最后走到了一条大路，也就是出现了相同的结果
这种就是 散列冲突

## 如何解决散列冲突？

- 寻址法 简单的说就是发现生成的那个整数被占用了，然后就往后找找到一个空闲的就住进去 包括这种方法 线性法 二次探测法 和多重探测法，
线性就是傻傻的一个一个往后找，二次探测就是第一次是1  第二次是2 第三次是4 第三次是 8 这种方式，多重就是搞几个函数，就不行了都不行？
大概就是这几种方法，但是如果数组中的数据真的快满了那么这几种都不好使，性能就不是O(1)了，甚至能退化成O(n)因为你要一个一个的往后找对吧，

 这里提出一个概念 装载因子 = 装了的/总共的 越大证明散列的性能越差。

 不过很多编程语言都会让散列表动态的扩容，例如go的map就是自动扩容的，所以你装的多，那么底层的数组就大就行了，这里我们也要看清楚
 扩容是扩容，但是需要数据的复制，所以扩容的时候非常的消耗，所以尽量按照len就设置一个map的len，这是最好的优化。，

- 链表法，也就是将这个数组的地方我们不是储存的value值了，而是储存的一个链表，就是算出来是这个值的统统放到这个桶里，然后再进行选择。
但是时间复杂度增加的时候还是O(1)因为毕竟找到桶然后直接丢到最后即可，但是查找或者是删除的时候就需要我们遍历这个链表，如果链表非常长的
时候，那么就要耗费了不少时间复杂度了 基本上平均数是 O(N/桶的个数)
