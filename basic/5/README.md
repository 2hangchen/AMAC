# 堆和堆排序

## 数据结构中的堆栈和内存中的堆栈

- 内存中： 的栈区处于相对较高的地址以地址的增长方向为上的话，栈地址是向下增长的。栈中分配局部变量空间。堆区是向上增长的用于分配计算机工程师申请的内存空间。另外还有静态区是分配静态变量，全局变量空间的；仅仅读区是分配常量和程序代码空间的；以及其它一些分区。

- 数据结构中：  堆和完全二叉树 然后 栈 是一种filo的结构。

## 堆

堆是一种完全二叉树，也就是那种叶子节点和上面那层节点就差一层，或者不差（那就是满二叉树了）然后叶子节点都在左边没有间隔节点的那种树结构

堆有两种条件：

- 完全二叉树
- 节点必须完全大于它的所有子树节点 --- 大顶堆，或者，节点必须完全小于它的所有节点 --- 小顶堆。

所以说堆这种数据结构只可以分为两种数据结构1.大顶堆 2 小顶堆，著名的TOPk问题，就可以使用最小堆来解决，REAME.md中的算法和数据结构中
的TOPk问题中我就使用了两种办法来解决topk问题一种就是快速选择（快速选择脱胎于快速排序，其实更简单，它的原理就是将三个区域中，只存在待求点的区域保留下来，然后没有待求点的就忽略即可，这跟快排有异曲同工之妙）还有一种就是最小堆，使用最小堆可以将数据从上到下排列，那要找top几只要查看排列的顺序即可。

## 堆化

我们往一个堆里插入数据，其实这个数据是插入到了这个底层的数组的最后一个位置，然后就不符合了堆的一般结构（节点全部大于子节点），然后我们就要堆化
也就是让这些数据符合堆的结构。

堆化分为两种
1. 从下往上
2. 从上往下

1 从下往上堆化

```go

for i/2 >0 && a[i] > a[i/2]{
  a[i],a[i/2] = a[i/2],a[i]
  i = i/2
}

```
2. 从上往下堆化
通常来说从上往下堆化就意味着数据是从后往前处理，然后堆化是相反方向，这种从上往下堆化的过程更好用
方法来说就是使用i 2i 和2i+1 即可。

这里说一下删除堆顶，也是有两种方式从下往上，从上往下，从下往上就是i很大慢慢减少，然后变得时候的过程是
先把堆顶删除，然后再从下面往上面补，来回切换变成堆，但是这种情况下容易造成叶子节点中间有些节点空掉，

所以采用从上往下的模式更好，这种方法的第一部是

- 先把 堆顶和最后一个交换位置，
- 然后我们就将这个堆的底层数组抛弃一个 ，
- 然后从上面那个堆顶往下开始一步一步的交换，

这里最重要的一步就是最后一个和堆顶交换，然后将整个的len减去一就是直接减掉了堆顶，

```go
a[cap+1],[1]  = a[1],a[cap+1] // 将 堆顶和最后一个交换位置，cap是容量，为什么+1 是因为数组从1开始计算
cap -- // 减去一个值，其实就是减去了最后的那个已经交换过的原堆顶，（感觉好凄凉，老队长被陷害，落到了最后然后被无情抛弃的情节。。。）
i := 1 //这就是新的栈顶数据
max := i // 给定一个值，这个值主要是为了记录新的栈顶是几号。栈顶 一步一步往下走。
for{
  if i * 2 < cap && a[i*2] > a[i]{
    max = a[i*2] // 这里 A
  }
  // 下面就开始 左右 开始比较了，上面是左 下面是右边。
  if i *2 +1 < cap && a[i*2+1] > a[i]{
    max = a[i *2+1] // 这里 B              AB 出主要是为了知道 新的栈顶（也就是往下一波的次大 是左边还是右边）
  }
 // 这里说明如果没有动 就是符合规定，就不用动了，就可以break出来了。
  if max = i {
    break
  }
  a[i],a[max] = a[max],a[i] // 然后 这里 将 大的往顶上传，
  i = max // 一步一步从上 往下走 所以i从1 变成了子树
}

```

插入是从下往上，删除是从上往下。删除主要是为了防止有空缺，而插入，从下往上可以顾及到每一个的节点，从上往下就不能了，因为要降树。

## 堆排序

其实堆排序使用从上到下的堆化即可，然后从后往前，每个除了叶子节点的值都做堆，直到最大的堆以此堆化，就可以排序了。
排序的过程也很容易，其实就是利用了删除堆顶的那种算法，然后一次一次的删除，一次一次的堆化然后直到最后一个然后就排好序了。

## 堆的几种用法

- 优先队列
  - 合并有序的小文件
  - 高性能定时器
- TOPK
- 求中位数

### 优先队列

什么是优先队列？队列是什么？队列是FIFO的一种结构，也就是说什么数据都是一样的民主的，一视同仁都是后来者居上，但是优先级队列就不是
优先级队列是谁重要谁先出去，比如说我们把最优先级的放在堆顶，然后让堆顶的大人先出去，这就是优先级队列，所以来说，优先级队列和队列
的区别就是 把顺序的谁后来谁先出 改为了 谁重要谁先出。

合并有序小文件 ：

首先我们假设我们有100个文件，每个文件1m，每个文件中有若干的字符串，很多很多，这些文件中的字符串都是按照顺序进行排列的，
现在我们要求将这些个100个文件中的字符串合并到一个大文件中，我们该怎么做？

首先我们知道每个文件中都是有序的，然后我们假设都是从小到大好了，我们可以取全部的第一个字符串放到数组中，然后进行小堆化，我们将最小堆也就是最小的那个拿出来放到大文件中当做大文件的最小值，假设这个字符串来自第89个小文件，例如说1.text，我们要做的就是从这个1.text中再取一个，按照顺序取，然后将这个字符串放到数组中，堆化（直接放堆最后，进行从下往上的堆化即可）然后再按照最小的顶堆取出来放到大文件的第二个，一次类推，直到取完，就完成了排序。

高性能计时器：

每到一个特定的时间间隔取堆顶就ok了，就不用轮询整个列表了，省去了轮询的时间。

TOPk：

有一个数组的数据，我们求前k，我们为之一个k大小的堆，然后堆里的数据是数组的前k个，堆化，然后往后的数据跟堆顶比较，如果比堆顶大，那么将堆顶删除
然后插入数据堆化，如果比堆顶小，则不用考虑。（最小堆堆顶是最小的）

中位数：

静态的中位数，直接排序然后取中间的一个或者两个（任选其一）即可。但是如果是动态的数字，中位数就不太一样了，因为数据在一直变化，

维持两个堆，一个大顶堆，一个小顶堆，小顶堆的数据全部大于大顶堆中的数据（各一半），换句话来说小顶堆的最小也就是顶堆也大于大顶堆的堆顶。

小顶堆
大顶堆

大概就是这么个排序。
这样的话大顶堆的顶堆就是中位数，然后我们动态该怎么办呢，如果新加的值小于大顶堆就插入大顶堆，然后堆化即可，如果值大于小顶堆，然后就插入小顶堆中
然后堆化。如果发现加入后不满足一半一半的要求了（如果总数是奇数那么就小顶堆比大顶堆少1即可，如果是偶数就一半一半），可以将有一方的堆顶值移到另一方，然后堆化即可。然后我们只要返回这里的大顶堆的堆顶，就是中位数。
