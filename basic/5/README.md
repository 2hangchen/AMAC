# 堆和堆排序

## 数据结构中的堆栈和内存中的堆栈

- 内存中： 的栈区处于相对较高的地址以地址的增长方向为上的话，栈地址是向下增长的。栈中分配局部变量空间。堆区是向上增长的用于分配计算机工程师申请的内存空间。另外还有静态区是分配静态变量，全局变量空间的；仅仅读区是分配常量和程序代码空间的；以及其它一些分区。

- 数据结构中：  堆和完全二叉树 然后 栈 是一种filo的结构。

## 堆

堆是一种完全二叉树，也就是那种叶子节点和上面那层节点就差一层，或者不差（那就是满二叉树了）然后叶子节点都在左边没有间隔节点的那种树结构

堆有两种条件：

- 完全二叉树
- 节点必须完全大于它的所有子树节点 --- 大顶堆，或者，节点必须完全小于它的所有节点 --- 小顶堆。

所以说堆这种数据结构只可以分为两种数据结构1.大顶堆 2 小顶堆，著名的TOPk问题，就可以使用最小堆来解决，REAME.md中的算法和数据结构中
的TOPk问题中我就使用了两种办法来解决topk问题一种就是快速选择（快速选择脱胎于快速排序，其实更简单，它的原理就是将三个区域中，只存在待求点的区域保留下来，然后没有待求点的就忽略即可，这跟快排有异曲同工之妙）还有一种就是最小堆，使用最小堆可以将数据从上到下排列，那要找top几只要查看排列的顺序即可。

## 堆化

我们往一个堆里插入数据，其实这个数据是插入到了这个底层的数组的最后一个位置，然后就不符合了堆的一般结构（节点全部大于子节点），然后我们就要堆化
也就是让这些数据符合堆的结构。

堆化分为两种
1. 从下往上
2. 从上往下

1 从下往上堆化

```go

for i/2 >0 && a[i] > a[i/2]{
  a[i],a[i/2] = a[i/2],a[i]
  i = i/2
}

```
2. 从上往下堆化
通常来说从上往下堆化就意味着数据是从后往前处理，然后堆化是相反方向，这种从上往下堆化的过程更好用
方法来说就是使用i 2i 和2i+1 即可。

这里说一下删除堆顶，也是有两种方式从下往上，从上往下，从下往上就是i很大慢慢减少，然后变得时候的过程是
先把堆顶删除，然后再从下面往上面补，来回切换变成堆，但是这种情况下容易造成叶子节点中间有些节点空掉，

所以采用从上往下的模式更好，这种方法的第一部是

- 先把 堆顶和最后一个交换位置，
- 然后我们就将这个堆的底层数组抛弃一个 ，
- 然后从上面那个堆顶往下开始一步一步的交换，

这里最重要的一步就是最后一个和堆顶交换，然后将整个的len减去一就是直接减掉了堆顶，

```go
a[cap+1],[1]  = a[1],a[cap+1] // 将 堆顶和最后一个交换位置，cap是容量，为什么+1 是因为数组从1开始计算
cap -- // 减去一个值，其实就是减去了最后的那个已经交换过的原堆顶，（感觉好凄凉，老队长被陷害，落到了最后然后被无情抛弃的情节。。。）
i := 1 //这就是新的栈顶数据
max := i // 给定一个值，这个值主要是为了记录新的栈顶是几号。栈顶 一步一步往下走。
for{
  if i * 2 < cap && a[i*2] > a[i]{
    max = a[i*2] // 这里 A
  }
  // 下面就开始 左右 开始比较了，上面是左 下面是右边。
  if i *2 +1 < cap && a[i*2+1] > a[i]{
    max = a[i *2+1] // 这里 B              AB 出主要是为了知道 新的栈顶（也就是往下一波的次大 是左边还是右边）
  }
 // 这里说明如果没有动 就是符合规定，就不用动了，就可以break出来了。
  if max = i {
    break
  }
  a[i],a[max] = a[max],a[i] // 然后 这里 将 大的往顶上传，
  i = max // 一步一步从上 往下走 所以i从1 变成了子树
}

```

插入是从下往上，删除是从上往下。删除主要是为了防止有空缺，而插入，从下往上可以顾及到每一个的节点，从上往下就不能了，因为要降树。

## 堆排序

其实堆排序使用从上到下的堆化即可，然后从后往前，每个除了叶子节点的值都做堆，直到最大的堆以此堆化，就可以排序了。
排序的过程也很容易，其实就是利用了删除堆顶的那种算法，然后一次一次的删除，一次一次的堆化然后直到最后一个然后就排好序了。

## 堆的几种用法

- 优先队列
  - 合并有序的小文件
  - 高性能定时器
- TOPK
- 求中位数

### 优先队列

什么是优先队列？队列是什么？队列是FIFO的一种结构，也就是说什么数据都是一样的民主的，一视同仁都是后来者居上，但是优先级队列就不是
优先级队列是谁重要谁先出去，比如说我们把最优先级的放在堆顶，然后让堆顶的大人先出去，这就是优先级队列，
