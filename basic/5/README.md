# 堆和堆排序

## 数据结构中的堆栈和内存中的堆栈

- 内存中： 的栈区处于相对较高的地址以地址的增长方向为上的话，栈地址是向下增长的。栈中分配局部变量空间。堆区是向上增长的用于分配计算机工程师申请的内存空间。另外还有静态区是分配静态变量，全局变量空间的；仅仅读区是分配常量和程序代码空间的；以及其它一些分区。

- 数据结构中：  堆和完全二叉树 然后 栈 是一种filo的结构。

## 堆

堆是一种完全二叉树，也就是那种叶子节点和上面那层节点就差一层，或者不差（那就是满二叉树了）然后叶子节点都在左边没有间隔节点的那种树结构

堆有两种条件：

- 完全二叉树
- 节点必须完全大于它的所有子树节点 --- 大顶堆，或者，节点必须完全小于它的所有节点 --- 小顶堆。

所以说堆这种数据结构只可以分为两种数据结构1.大顶堆 2 小顶堆，著名的TOPk问题，就可以使用最小堆来解决，REAME.md中的算法和数据结构中
的TOPk问题中我就使用了两种办法来解决topk问题一种就是快速选择（快速选择脱胎于快速排序，其实更简单，它的原理就是将三个区域中，只存在待求点的区域保留下来，然后没有待求点的就忽略即可，这跟快排有异曲同工之妙）还有一种就是最小堆，使用最小堆可以将数据从上到下排列，那要找top几只要查看排列的顺序即可。

## 堆化

我们往一个堆里插入数据，其实这个数据是插入到了这个底层的数组的最后一个位置，然后就不符合了堆的一般结构（节点全部大于子节点），然后我们就要堆化
也就是让这些数据符合堆的结构。

堆化分为两种
1. 从下往上
2. 从上往下

1 从下往上

```go

for i/2 >0 && a[i] > a[i/2]{
  a[i],a[i/2] = a[i/2],a[i]
  i = i/2
}

```
