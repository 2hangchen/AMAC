### 如何计算时间和空间的复杂度。

公式：`T(n) = O(fn(n))` 平时我们看到的样子是这样的`O(n)`

#### 时间复杂度

求解的时候要注意一个原则：去掉低阶，去掉常数，去掉最高阶的常数，例如：`2n^2 + 2n + 1` 它的时间复杂度就是 `O(n^2)`
所以说啊，时间复杂度就是一个估计值，举个例子
```go
for i := 0;i < n ;i++ {
  for j := i;j <n;j++ {

  }
}
```
外层循环那么肯定是N 因为是循环那么那么的中间肯定是`x`，所以说外层是N，内层，因为根据i的变化而变化，比如第一次循环就是n次，第二次就是n-1次，第三次就是n-2次那么结果就是`(n^2-n)*0.5` 所以最后取大头就等于`n^2`

列举几个平时经常看到的时间空间复杂度，按照速度顺序列举，越靠前，时间越少，速度越快。

`1 > logn > n > nlogn > n^2 > n^3 > 2^n > n! > n^n`

第二种计算方式就是嵌套相乘法：

只要是嵌套，那么就使用内部乘以外部就ok了，例如nlogn就是一个logn的算法执行了n倍。

我们来具体解释一下，为什么二分法是logn具体来说是log2n

二分法的最后一步就是只剩下了1，也就是找到了那个数值，加入说将这个过程倒过来呢？
```go
1 2 4 8

//也就是

2^0 2^1 2^2 2^3... 2^x = n
```
也就是说 执行了x次才能等于n ，那么二分法只不过是每次都除以2而已，次数是一样的，所以x = log2n 也就是 logn

nlogn呢？更好理解， 让循环n次来执行二分法，那么这个算法就是nlogn因为是嵌套关系，所以用乘法。

#### 空间复杂度

空间复杂度就是在操作某个算法的时候需要额外消耗多少的内存空间。具体的可以举个例子

```go
a := make([]int,10)
```
给定一个切片，让你去这个切片的前9位，那么这个空间复杂度是多少？
就是`O(1)`了，因为你并没有开辟新的空间，如果是递归呢？

其实也很容易理解，空间复杂度就是`O(n)`举个例子

```go
func A(n int){
if n <=0 {
  return
}

  A(n-1)
}
```
这个我们可以看到循环了，知道n=0才可以出栈，所以栈空间而言，向上堆砌了N次,所以它的空间复杂度就是`O(n)` 那么时间复杂度是多少?
这个算法中的时间复杂度也是`O(n)` 因为n不同循环的次数也不同，n等于1循环1次n等于10循环10次
