## 数组

### 基本储存类型

其中的bit的单位是位 也就是 二进制中的位数 比如 10010就是5位

1 Byte（B） = 8 bit

1 Kilo Byte（KB） = 1024B

1 Mega Byte（MB） = 1024 KB

1 Giga Byte （GB）= 1024 MB

1 Tera Byte（TB）= 1024 GB

1 Peta Byte（PB） = 1024 TB

1 Exa Byte（EB） = 1024 PB

1 Zetta Byte（ZB） = 1024 EB

1Yotta Byte（YB）= 1024 ZB

1 Bronto Byte（BB） = 1024 YB

1Nona Byte（NB）=1024 BB

1 Dogga Byte（DB）=1024 NB

1 Corydon Byte（CB）=1024DB

1 Xero Byte （XB）=1024CB

例如int类型就是32位，也就是一个int是 00001111100 （32个组成的）所以它的占有的byte大小就是4 也就是下面说到的 1000 - 1003 这说明的单位是byte 也就是字节。不是比特。

顺便提一下 带宽的单位是bit 比如说 8Mbit 我们翻译一下就是 9m的比特带宽 转化成 bite就是 1mbyte 然后带宽都是秒嘛 所以 下载的速度就是 1Mbyte/s 等于8Mbit/s  通常我们都用byte为最小单位,因为bit 这个单位太小了。一个bit类型才装一个二进制的数字，一个 int就需要32个数字。

> PS : bite 使用b作为缩写 Byte使用B 作为缩写，所以这里打大小写不能搞错了。
### 数组长什么样？

|下标|数组(连续排列的内存空间)要求类型必须一样|内存空间地址|
|:-:|:------:|:---:|
|0|[1]| 1000-1003|
|1|[2]| 1004-1007|
|2|[3]| 1008 - 1011|
|3|[4]| 1012 - 1015|

在go中数组叫做array 但是通常我们经常使用切片。也就是slice。slice就是数组的引用类型罢了具体应该是这样的

```go
a := [10]int{}
sl := struct{
  *a
  len(a)
  cap(a)
}
//比如sl[:8]

sl= struct{
  &a
  8
  10
}
```

在数据结构上分为两种结构：1 线性表 2 非线性表

1. 数组，队列(FIFO)，链表，栈(FILO)

2. 二叉树，堆，图 等。也就是前后没有对应关系的数据结构都是非线性表

### 数组为什么可以任意访问？

- 它是连续内存 ：证明他们之间的地址是连续的

- 它是统一类型 ： 证明每个类型都是一样的，那么大小当然也是一样的

举个例子

0 位置的数组 地址是 1000-1003 1 是 1004-1007 那么为什么地址是 一段区间不是一个地址呢？原因就是因为type的大小问题，一个int大小的类型
在32位上占有4个字节，那么它的地址区间就是 4个数字就是1004-1007了我们要找的就是第一个地址，也就是首地址，找到它就ok了，所以我们有这么的一个计算方法：

 `地址[i] = 首地址（这里假定是 1000） + i * type大小 所以第一个地址就是 1000了，第二个就是 1000+4 = 1004了，` 那么双层的怎么计算呢？
 对于一个 m n的数组 计算方法是这样的 `地址[i][j] = 首地址+ i *n + j `举个例子：

 ```go
[[123][456]]
 ```
 寻找到第二行第二个怎么找？ 也就是 [1][1] = 1000+ (1*3+1)typesize = 1016

 所以说这就是为什么数组可以马上就找到下标为某某的那个数据，因为它是纯靠计算得来的。而且它连续，并且每个数据大小一样。

 ### 数组的删除和增进的时间复杂度是多少呢

增进： 最好的情况从最后一个增进 那么就是O(1)最差的就是从第一个开始增进 那么算起就是O(n)因为它要把后面的数据全部向后迁移一位很麻烦对吧，所以数组有时候很慢的，平均是多少呢 `1/n * n + 1/n *n -1 + ....1 *1/n = 1/n(1+n)n/2 = n` 所以加权平均时间复杂度就是`o(n)`

优化方法1（查找的时候） ： 使用二分法进行查找 然后时间复杂度可以在 O(logn)

优化方法2 在没有顺序是数组中，加入说 想在2这个下表加入一个数据然后将后面的数据全部后移的操作中，我们可以将原来的2 先新命名到最后一个，然后将这个2替换成我们这里的数据即可

优化方法3 删除的时候， 比如我们有一个数组 1 2 3 45 我们要求删除 123 那么 如果我们按照我们往常的算法 先删除1 全体搬移一次，然后再删除2 又搬移了一次，然后再删除3 又一次。。。。 所以我们可以这么干 先标记1被删除了，但是我们不是真的删，然后再标记2 3 这时候我们可以看到数组中还是一样的，但是看起来就剩了 4 5 那么比如说 这个数组要增加数据了，怎么办？这个时候再统一删除 1 2 3 然后直接将 4 5 搬移 就会节省 2倍的时间。在标记了 123 取 45 的 时候我们也可以使用i + n 这种方法取 4 5  比如 4 我们看来它已经是0了 然后我们标记了 3次 我们就可以是 使用 0 + 3 这种方法去得到4

在go中我们大可直接使用slice但是，如果遇到了扩容问题，那么会有资源的复制，所以在go中的优化，我们可以直接指定slice的len和cap是我们直接想要的大小，就可以避免了扩容问题。
