# IO复用

IO复用是通过某种机制对于多个socket，哪个socket数据变的可读，使用recvform把数据从内核缓冲区复制到进程缓存区。

IO复用的过程中需要用到三种方法分别是 Select poll epoll

select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理

其中前两者并没有本质上的区别，都是完全不知道究竟是哪个请求已经好了，只能是轮序所有的监听对象，然后Select比Poll要快的原因就是
Select是利用的数组，然而Poll是用的链表来储存已经好的请求对象的，所以说数组只能存放单一类型并且有数量的限制，但是链表就可以不限制
相同类型这个然后数量上也不限制，但是速度上肯定是比不了数组的索引了。这就是说如果要求不是特别的紧急的情况下一般常规的poll更好
因为它使用的链表可以容纳的更加宽容，但是如果是非常非常的高效那么必须使用select因为没有比数组的索引更快的了。瞬间就可以找得到。但是前提是
要求请求流不能太多。

select和poll因为都是轮询然后看哪个是准备好了，所以说它的时间复杂度就是O(n)，因为要一直轮询嘛。然而epoll的却是O(1)
因为它才是真正的事件驱动型，哪个流好了就返回，然后直接通知epoll，这样的话时间复杂度肯定就是o(1)

但是他们三个都是同步Io处理方式，，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。  

epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。

具体epoll的实现可以参考nodejs中的js异步的过程，先返回一个值，但是这个值有一个callback，然后进行下面的工作，直到callback返回了，那个前面的那个工作才算是真的结束。这就是epoll的模式


epoll的优点：

1. 没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；
2. 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；
即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。

3. 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。


select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。

select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。

消息传递方式

select 内核需要将消息传递到用户空间，都需要内核拷贝动作,poll同上,epoll 通过内核和用户空间共享一块内存来实现的。

## 总结

select和poll靠的是每次的轮序，epoll是靠的回调函数。回调好了以后就放入到就绪表中（它也需要轮序，但是轮序的对象不是每个socket，而是就绪表，这个表当然就简单很多了。）数量上 select有限制，poll无限制 epol也有限制但是上限很大。select和poll复制信息都是直接复制而epoll是共享内存空间
相对的速度肯定就快了，因为不用复制了啊。epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，

在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符fd进行扫描，而epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。

所以说select和poll都是用的时候再说，而epoll是实现准备好然后直接全部callback，谁先back了就往那个就绪表中加入。所以它只需要将所有的fd复制到
用户内核中一次即可，因为谁callback了谁就是活跃的那么启封这个fd即可。
