# 死锁

在go中如果你的并发写不好了经常会出现 deadlock 这个英语短语翻译成中文就是死锁。

## 死锁的发生条件

- 互斥：资源要么已经分配给了一个进程，要么就是未被使用的已经准备好的状态。
- 占有和等待：已经得到某个资源的进程还想要其它资源，俗称吃着碗里的看着锅里的
- 不可抢占：已经分配给一个进程的资源，在其未被释放的时候其它的进程是不能强制的争夺的。
- 环路等待：有两个或者两个以上的进程组成一条环路，这些进程都在**等待**下一个进程正在使用的资源（想赶紧自己也使用，这么贪当然就死锁了）

## 鸵鸟政策
像鸵鸟一样，直接忽略这个死锁即可。

比如在go中，如果发生了死锁就会panic，我们直接在使用的时候直接recover即可，只要是panic就直接忽略就行了。
## 死锁的检测问题和恢复算法
其实可以使用深度优先搜索，准确的说是图的有向图的深度优先搜索，如果发现顶点的链表中发现了重复出现的顶点，就可以判断了，死锁了。

- 死锁恢复

利用抢占恢复，利用回滚恢复，通过杀死进程恢复

其中杀死进程的最简单，直接如果遇到重复的顶点，直接kill就完事儿了。
## 如何预防死锁问题
在程序运行之前预防发生死锁。

- 如果检测到死锁，我们可以对这些资源进行编号，不要这种死锁的杂乱的运行顺序，按照编号进行运行，可以在运行期避免死锁


## 如何避免死锁问题
在程序运行时避免发生死锁。
