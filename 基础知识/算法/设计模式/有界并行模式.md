# 有界平行模式

核心思想就是首先 一写多读，而且不管是写还是读都要新开协程，这样不会死锁，
chan 不发就不能收，但是close后就可以接收了，所以这是个技巧直接close 就可以接收信息
但是记住close的chan不能发  发就Panic

看这段代码，很多地方都是开了协程，开协程就意味着不会阻塞，如果所有的协程都是阻塞的就是该死锁了

阻塞和运行是两回事，time.sleep也不会阻塞，它只是在等待，死锁是所有的协程没有希望的堵住 .

另外select case出可以发也可以收，发就是 发的时候走这个case
```go
func main() {
	data, err := ReadFile("/Users/googege/Desktop/myProject/GOFamily")
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(data)
}
func ReadFile(root string) ([]string, error) {
	ma, err := Read(root)
	var path []string
	for k := range ma {
		path = append(path, k)

	}
	sort.Strings(path)
	for k,v := range path {
		t := fmt.Sprintf("%x",ma[v])
		path[k]= t+":--->"+v
	}
	return path, err
}

// return the paths.
func WalkFile(done chan bool, root string) (<-chan string, <-chan error) {
	paths := make(chan string)
	err := make(chan error, 1)
	go func() {
		defer close(paths)
		err <- filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			// if is not file ,return nil.
			if !info.Mode().IsRegular() {
				return nil
			}
			select {
			case paths <- path:
			case <-done:
				return fmt.Errorf("done")
			}
			return nil
		})
	}()
	return paths, err
}

// return result .
type resultValue struct {
	path string
	data [md5.Size]byte
	err error
}

// file recipient.
func FileRecipient(done <-chan bool, paths <-chan string, result chan *resultValue) {
	for path := range paths {
		data, err := ioutil.ReadFile(path)
		select {
		case result <- &resultValue{
			path: path,
			data: md5.Sum(data),
			err:  err,
		}:
		case <-done:
			return
		}
	}
}

func Read(root string) (map[string][md5.Size]byte, error) {
	done := make(chan bool)
	defer close(done)
	paths, err := WalkFile(done, root)
	c := make(chan *resultValue)
	var wg = sync.WaitGroup{}
	wg.Add(20)
	for i := 0; i < 20; i++ {
		go func() {
			FileRecipient(done, paths, c)
			wg.Done()
		}()
	}
	go func() {
		wg.Wait()
		close(c)
	}()
	ma := make(map[string][md5.Size]byte)
	for k := range c {
		if k.err != nil {
			return nil, k.err
		}
		ma[k.path] = k.data
	}
	if err := <-err; err != nil {
		return nil, err
	}
	return ma, nil
}

```
