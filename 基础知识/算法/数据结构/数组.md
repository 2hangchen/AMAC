# 数组
> 字符串是由数组构成的。

go中的数组`arr1 := [1]int{1}`,与此同时还应该对应着一个非常像的数据结构切片`sli1 := arr1[:]`
切片的数据结构如下

```go
type Slice struct {
  Cap int
  Length int
  Array unsafe.Pointer
}
```
所以说我们可以认为，go中任何的数据结构都是实际的复制，就连引用类型也是，只不过，引用类型内部是一个非
引用类型的地址。

## go中关于切片的操作

 ```go
 sli1 := make([]int, 2,5)
 sli1 = append(sli1,3)
 // sli1 = []int{0,0,3}


 ```
这里对append做一个总结，也就是说append获取的最后的值是按照length来获取的，并不是cap，在go中任何的越界等
行为都是按照length来决定的，不是cap。

 举个例子

 ```go
    sli1 := make([]int,2,5)
    sli1  = append(sli1,3)
    sli1[4] = 1
    fmt.Println(sli1)
 ```

 output:  panic: runtime error: index out of range [4] with *length* 3
main.main()

所以说不管是append或者是copy，都是针对的length，cap只是底层数组的长度，仅此而已，然后切片是动态扩容的。

下面说一下copy

```go
  sli1 := make([]int,2,5)
  sli1  = append(sli1,3)
  sli2 := make([]int,2,5)
  sli2[0] =1
  copy(sli2,sli1) // 这一步就证明了，copy操作也是对于len，并且它会将前者清空。
  fmt.Println(sli1)
  fmt.Println(sli2)
```
output：

`[0 0 3]
[0 0]
`

## 总结
- go中的数组系列中，切片才是最常用的
- 切片的操作一切的包括越界，复制，等等是看的length不是cap
