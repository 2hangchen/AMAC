# maximum product subarray
## 解法一

暴力递归求解，当然也可以说是回溯求解。甚至说是深度优先搜索都OK。反正基本上一个意思。

写法是对的，但是超过了时间限制，因为时间复杂度真的太高了，是指数级别的。
```go
func maxProduct(nums []int) int {
    max := -1<<63
    c_maxProduct(nums,&max,1)
    return max
}

func c_maxProduct(nums []int,max *int,cur int){
    // stop 
    if len(nums) == 0 {
        return 
    }
    // process & trill down
    value := nums[0]
    maxT := max
    // Y
    cur *= value
     if *max < cur {
        *max = cur
    }
    c_maxProduct(nums[1:],max,cur)
    // N
    cur = 1
    c_maxProduct(nums[1:],maxT,cur)
    // clear states
}
```
## 解法二

动态规划

```go
```
