# topk
## 解法一 堆

```go
type KthLargest struct {
	k int
	hea *heapInt
}


func Constructor(k int, nums []int) KthLargest {
	var kt KthLargest
	kt.k = k
	var h heapInt
	h = nums
	kt.hea = &h
	heap.Init(kt.hea)
	if len(nums) < k {
		return kt
	}else {
		for kt.hea.Len() > k {
			heap.Pop(kt.hea)
		}
	}
	return kt
}


func (this *KthLargest) Add(val int) int {
	value := 0
	if this.hea.Len() < this.k{
		heap.Push(this.hea,val)
		value = heap.Pop(this.hea).(int)
		heap.Push(this.hea,value)
	}else {
		v := heap.Pop(this.hea).(int)
		if v <= val{
			heap.Push(this.hea,val)
			value = heap.Pop(this.hea).(int)
			heap.Push(this.hea,value)
		}else {
			heap.Push(this.hea,v)
			value = v
		}
	}
	return value
}

type heapInt []int
func(h heapInt)Len()int{
	return len(h)
}
func(h heapInt)Less(i,j int)bool {
	return h[i]<h[j]
}
func(h heapInt)Swap(i,j int){
	h[i],h[j] = h[j],h[i]
}
func(h *heapInt)Push(x interface{}){
	*h = append(*h,x.(int))
}
func(h *heapInt)Pop()interface{}{
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}
/**
 * Your KthLargest object will be instantiated and called as such:
 * obj := Constructor(k, nums);
 * param_1 := obj.Add(val);
 */

```
