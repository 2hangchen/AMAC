# n-queens N皇后问题

这道题非常经典
## 解法一
回溯+剪枝

```go
func solveNQueens(n int) [][]string {
	Mcol := make(map[int]int)
	Mpie := make(map[int]int)
	Mna := make(map[int]int)
	result := make([][]string, 0)
	re := make([]string, 0)
	mo(Mpie, Mna, Mcol, &result, re, n, 0)
	return result
}
func mo(Mpie, Mna, Mcol map[int]int, result *[][]string, re []string, n, row int) {
	if row > n-1 {
        ttt := make([]string,len(re))
        copy(ttt,re) // 这里的copy是害怕以后的re改变会对这个数据造成影响。
		*result = append(*result, ttt)
		return
	}
	for i := 0; i < n; i++ {
		_, ok1 := Mpie[row+i]
		_, ok2 := Mna[row-i]
		_, ok3 := Mcol[i]
		if ok1 || ok2 || ok3 {
			continue
		}
		Mpie[row+i]++
		Mna[row-i]++
		Mcol[i]++
		mo(Mpie, Mna, Mcol, result, append(re, ddtt(i, n)), n, row+1) // 这里的append就是防止了re被污染。因为他还有后继的遍历要走
		delete(Mpie, row+i)
		delete(Mna, row-i)
		delete(Mcol, i)
	}
}

func ddtt(i, n int) string {
	result := ""
	for j := 0; j < n; j++ {
		if j != i {
			result = result + "."
		} else {
			result = result + "Q"
		}
	}

	return result
}

```
