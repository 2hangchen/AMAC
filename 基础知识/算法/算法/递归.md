# 递归

## 斐波那契数列
`1 1 2 3 5 8 13` 这个斐波那契数列的递归方程是`F(n) = F(n-1)+F(n-2)`其中n是角标。这个函数，当遇到n是0或者是1的时候就可以返回值了，为啥呢，因为当n=1orn=0的时候他们的值都是1，而且是最小的两个数字了。
```go
func fi(n)(value int){
  if n == 1|| n == 2{
    return 1 
  }
  return fi(n-1)+ fi(n-2)
}
```
这种计算方法其实使用到了大量的重复的数据，所以说这种简单的递归，会对性能造成很大的影响，时间复杂度也不低，
它的时间复杂度是`2^n`怎么算出来的？很简单吗，每次都被分裂为2，2的每一个又是分裂成2这就是细菌的传染过程嘛
那么细菌的传染过程就是指数级别的，所以这个时间复杂度就是2的指数级别。

## 递归优化的重要性

我们还是拿斐波那契数列来出说

上文是普通的拥有大量的重复计算的斐波那契数列

这是一个记录了不同的n的计算结果的优化版的斐波那契数列
```go
var (
	ma = map[int]int{}
)
func fi(n int)int{
	if n ==1 || n == 2 {
		return 1
	}
	if v,ok := ma[n];ok { // 使用了哈希表来记录结果
		return v
	}
	value := fi(n-1)+fi(n-2)
	ma[n] = value
	return value
}

```

我们看一下当n等于40的时候，时间能差距多少

```go
package main

import (
	"testing"
)

var (
	n  = 40
)

func BenchmarkFi(b *testing.B) {
	for i := 0; i < b.N; i++ {
		fi(n)
	}
}
func BenchmarkFi2(b *testing.B) {
	for i := 0; i < b.N; i++ {
		fi2(n)
	}
}
```

输出结果

```go
goos: darwin
goarch: amd64
pkg: github.com/googege/test
BenchmarkFi
BenchmarkFi-4    	63431078	        17.8 ns/op
BenchmarkFi2
BenchmarkFi2-4   	       2	 636617175 ns/op
PASS

Process finished with exit code 0
```

同样的结果，不同的算法差距是 35765009.8 倍

对于递归，或者是重叠子问题的优化，这也是动态规划的核心之一，将大量重叠的计算省去，可以节省大量的时间。
