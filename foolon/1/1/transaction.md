# 事务
- 本地事务
- 分布式事务

事务的目的是为了追求数据的一致性，因此有了 acid 理论

事务要达成的一致性可以分为，`内部一致性和外部一致性`，如果是单机中且只有一个数据来源时，是内部一致性，这种一致性可以依靠acid理论来搞定，因为数据执行的顺序可以被控制，而多数据来源时，通常是跨设备的分布式场景下，就是外部一致性，通常无法通过acid来搞定，因为数据执行的顺序是不固定的，来源很多。

也可以分为`强一致性，相对一致性，最终一致性`，在分布式系统中，基本上无法实现强一致性，通常我们会实现相对一致性，比如raft等协议要求一致的数据大于50%即可，或者某个数值即为一致，还有一种是最终一致性，即最终实现一致即可，中间过程不一致也无所谓，简单的例子比如微信头像在多终端的表现，你可能发现手机上改变了，但是登陆的电脑端并没有改变，但是最终会改变，这就是最终一致性。
## 本地事务
局部事务的达成主要依赖底层数据源提供的事务能力，比如mysql提供的事务能力，局部事务在代码层面是不能做出事务的能力的，这跟全局事务，共享事务，以及分布式事务不一样，局部事务仅仅可以作为封装了底层源事务的一个接口，并且在局部事务中，数据源只能有一个，比如mysql，或者redis，但是只能有一个数据来源。其余的事务，基本上都是从代码的层面去认为的创造出一个事务的。

### 实现原子性和持久性
原子性：不会存在中间状态，持久性：要求不能被更改，在实现原子性和持久性的难题就是当数据被写入磁盘的时候，会存在第三种可能，就是写一半的现象

为了保证程序修改，和数据库的一致性，一般采用日志的方式进行记录操作，当日志记录完成以后才会去对于数据库数据进行真正的修改，这个时候既不会存在修改一半的现象，要么就是日志写入成功，那么数据库数据一定会成功，要么是日志写入失败，数据库一定不成功

为了优化io性能，数据库提出了两个原则 steal force ，前者的意思是在事务提交前是否允许更改磁盘上的数据，后者的意思是是否允许在事务提交后立马更改磁盘上的数据，总而言是，日志是保证数据库原子性和持久性的必备工具。
### 实现隔离性
隔离性和并发有很大的关系，因为隔离性的意义就是防止数据互相牵连，a操作不能影响b的结果，所以现代数据库实现的事务，要用锁来实现隔离性，通常拥有三种锁
- 写锁

    写锁，只能允许某个事务进行写操作，也不能给它读锁（**但是可以读**）
- 读锁

    可多个事务对一个数据添加多个读锁，数据被加了读锁后不允许被加上写锁，其它事务不能写，但是可以读，若只有一个事务给data添加了读锁，可以添加写锁
- 范围锁

    给某个范围一个写锁，在这个范围内某个事务只能写，其余事务不能写也不能添加读锁（仍然是可以读），也不能在这个范围内新增和删除

根据加锁的范围，长短，和类型，一般可以将隔离性分为 “串行” “可重复读” “读已提交” “读未提交”
## 分布式事务
### 可靠事件队列
使用一个消息队列进行事务的操作，结构简单，但是隔离性不足，有可能会发生类似超售这种情况
### tcc
将业务逻辑分为了预留业务过程，和确认/释放消费资源过程
- try

    尝试执行阶段，完成所有业务的可执行性的检查，预留好全部要用到的资源，然后把资源标记为类似“冻结”状态
- confirm

    不进行任何的检查，直接使用try阶段准备好的资源，此阶段有可能会因为网络问题发生重复操作的现象，因此要保证幂等性
- cancel

    释放try阶段预留的业务资源，并且支持幂等性

这种模式非常类似于在分布式协议中的paxos中的提交过程，即：拥有准备阶段，正式提交阶段，以及取消操作，这种事务模式可以不用考虑锁这种东西，因为有预留嘛。

案例：

购买商品，可以遇见的是try阶段，仓库，操作用户的账户，商家，都要先准备好，并且划归为冻结状态，然后进入具体执行过程，如果执行成功那么就完成了这项操作，如果不成功就进入cancel状态，将所有的数据回归原始

所以说这种方法的关键是 “预处理” ，冻结将要处理的东西。
### saga

整个saga事务可以分为两个阶段
- 大事务分为若干小事务，并且小事务应该是原子性的，并且小事务加在一起的结果应该和大事务的结果是一样的（即：最终一致性）
- 为每一个子事务都设计补偿动作，并且满足下面的条件
    - 子事务和补偿动作都具有幂等性
    - 子事务和补偿动作满足交换律
    - 补偿动作必须成功，不成功就重复提交或者人工介入

如果子事务某个产生了问题，那么执行下面的操作

- 正向恢复，子事务如果发生错误，就一直重试，直到成功
- 反向恢复，子事务发生错误，子事务的补偿动作一致重复操作，直到成功

这种方法需要详细的日志，避免事务执行失败。