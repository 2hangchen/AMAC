# 多级分流系统

- 客户端缓存
- 域名解析
- 传输链路
- 内容分发网络
- 负载均衡
- 服务端缓存

系统可以分为三种类型

- 边缘服务：例如浏览器缓存，cdn
- 易扩展服务：例如提供服务的集群
- 单点服务：例如数据库

在系统中，应该尽量减少单点服务的访问及流量，以及不要过于复杂，能满足要求的技术即可，过于复杂有可能适得其反。
## 客户端缓存
客户端缓存是为了减轻服务端的压力而设计的，因为http协议和服务器之间是无状态的，所以前后两次的访问请求，并没有什么关系，也就是独立的，这就造成http的每次请求都要带有重复的数据，一大堆的数据必然拖累了连接效率，所以尽量减少联接就称为了优化的方向，那么客户端的缓存就可以解决这个问题。

- 状态缓存

    指的是不经过服务器，直接进行**根据缓存信息**作出的行为，比如301强制重定向。

- 强制缓存

    根据服务器返回的参数，在某个时间点之前，浏览器**强制缓存不用请示服务器**，在浏览器的动作中，除了 “刷新” 动作会不使用这个缓存，其余动作，例如后退，前进，跳转，搜索，地址输入框输入地址，都会使用这个缓存。

    使用http1.1提供的 Cache-Control 参数可以设定失效时间其中它包含了一些参数，分别是：
    - max-age：请求缓存的时间 
    - s-maxage：共享缓存的请求时间，比如cdn，代理，public private：是否牵涉到隐私资源，如果是private那么cdn等共享的系统将无法获取此资源
    - no-cache no-store：表示此资源不应该被缓存
    - no-transform：禁止资源被修改min-fresh：只用于客户端的header，表示服务器返回的max-age的最小值
    - only-if-cached：客户端要求，服务器不必给它发送具体的缓存内容
    - must-revalidate proxy-revalidate：表示过期后，资源一定要从服务器中获取

- 协商缓存

    根据变化**不断检测**的一种缓存机制，跟强制缓存属于并行机制，
    - last-Modified 服务器响应字段，最后响应时间 
    - if-Modified-Since 客户端字段，表示资源最后的修改时间，如果服务器发现资源还没有过期直接返回304，如果发现过期了就返回真实的数据
    - Etag 服务器返回的资源唯一id
    - if-None-Match 客户端将id通过此字段传递给服务器用于验证资源

    协商缓存在用户刷新的时候同样有效果，这个比强制缓存还厉害
## 域名解析
dns是域名和IP地址的翻译系统，整个系统的zone部分只有2mb大小，dns系统分为权威域名服务器和根域名服务器，根域名服务器其实就是一个`.` ，比如`www.github.com`那么系统会自动给它添加一个`.` 变成了 www.github.com. 最后那个.就是根服务器，然后在根服务器前面的都称为是权威服务器，那么根服务器里面主要存的就是顶级域名的服务器地址了，例如.com .cn .hk 这种级别的服务器地址。 

dns当然也是有本地缓存的，当访问URL的时候，系统会默认去访问本地的dns缓存，当然有一个失效时间，如果没有任何设置的话，远程服务器的URL和ip进行了更改，本地的缓存必须等到失效才能进行更新。

在访问本地dns缓存的时候会从`www.example.com`  => `example.com` => `.com` => `.` 的次序去查找本地的缓存，假如，`www.example.com` 是没有的，那么查询到`example.com`是有的，它就会从直接寻找到这个缓存里的服务器地址，然后从这个地址里去远程查找到`www.example.com` 最终要找的ip或者其它形式的地址信息。所以说dns服务器也是分层次的，按照每层的方式去查找，并且，每一层的dns地址都是有缓存的机制，并且如果更改必须等待失效

因为dns是多分层的查找机制，每一层都是缓存，如果想查找的URL，在本地没有一层有缓存，那么就注定了响应时间非常长，这是第一个缺点，解决方法就是配置一个预获取地址的一个标签`<link rel="dns-prefetch" href="//cdn.eed.com">`

第二个缺点是，非常容易被攻击，也就是所谓的dns劫持，比如说你要查找 www.github.com 在你的本机存有 `.com`服务器的缓存地址，然后就没有了，那么你把这个缓存里面的服务器的地址取出来，比如说是89.87.43.1 然后你访问了这个地址，从里面开始查找 github.com 然后返回回来一个ip，这个时候你再访问这个ip，比如说是98.34.123.43 然后你再这个服务器中查找 `www.github.com`的地址ip，这个时候你才会真正的找到真实的ip地址，我想说的被攻击，比如说你本地存放的.com 地址就是假的，然后你返回给你的ip就不是真的github.com 它可能是伪造的，然后你访问了这个地址，那么这个地址呢就会去访问真的github.com,不过它会在真的内容里加上一些html比如广告，这个时候你自己也访问到了真实的github.com了，诶只不过你访问的内容被dns服务商给加了点广告。这是最友好的劫持了。

解决dns其实也简单，比如说你不靠系统去获取所谓本机的缓存dns服务器的地址，你自己用程序主动获取一个权威的，而且使用https去获取不使用传统的udp，这个时候返回的结果就是正确的，然后你再一层一层的这么干，直到查找到真实的ip或者其它形式的地址。

## 传输链路

## 内容分发网络

## 负载均衡

## 服务端缓存
