# 多级分流系统

- 客户端缓存
- 域名解析
- 传输链路
- 内容分发网络
- 负载均衡
- 服务端缓存

系统可以分为三种类型

- 边缘服务：例如浏览器缓存，cdn
- 易扩展服务：例如提供服务的集群
- 单点服务：例如数据库

在系统中，应该尽量减少单点服务的访问及流量，以及不要过于复杂，能满足要求的技术即可，过于复杂有可能适得其反。
## 客户端缓存
客户端缓存是为了减轻服务端的压力而设计的，因为http协议和服务器之间是无状态的，所以前后两次的访问请求，并没有什么关系，也就是独立的，这就造成http的每次请求都要带有重复的数据，一大堆的数据必然拖累了连接效率，所以尽量减少联接就称为了优化的方向，那么客户端的缓存就可以解决这个问题。

- 状态缓存

    指的是不经过服务器，直接进行**根据缓存信息**作出的行为，比如301强制重定向。

- 强制缓存

    根据服务器返回的参数，在某个时间点之前，浏览器**强制缓存不用请示服务器**，在浏览器的动作中，除了 “刷新” 动作会不使用这个缓存，其余动作，例如后退，前进，跳转，搜索，地址输入框输入地址，都会使用这个缓存。

    使用http1.1提供的 Cache-Control 参数可以设定失效时间其中它包含了一些参数，分别是：
    - max-age：请求缓存的时间 
    - s-maxage：共享缓存的请求时间，比如cdn，代理，public private：是否牵涉到隐私资源，如果是private那么cdn等共享的系统将无法获取此资源
    - no-cache no-store：表示此资源不应该被缓存
    - no-transform：禁止资源被修改min-fresh：只用于客户端的header，表示服务器返回的max-age的最小值
    - only-if-cached：客户端要求，服务器不必给它发送具体的缓存内容
    - must-revalidate proxy-revalidate：表示过期后，资源一定要从服务器中获取

- 协商缓存

    根据变化**不断检测**的一种缓存机制，跟强制缓存属于并行机制，
    - last-Modified 服务器响应字段，最后响应时间 
    - if-Modified-Since 客户端字段，表示资源最后的修改时间，如果服务器发现资源还没有过期直接返回304，如果发现过期了就返回真实的数据
    - Etag 服务器返回的资源唯一id
    - if-None-Match 客户端将id通过此字段传递给服务器用于验证资源

    协商缓存在用户刷新的时候同样有效果，这个比强制缓存还厉害
## 域名解析
dns是域名和IP地址的翻译系统，整个系统的zone部分只有2mb大小，dns系统分为权威域名服务器和根域名服务器，根域名服务器其实就是一个`.` ，比如`www.github.com`那么系统会自动给它添加一个`.` 变成了 www.github.com. 最后那个.就是根服务器，然后在根服务器前面的都称为是权威服务器，那么根服务器里面主要存的就是顶级域名的服务器地址了，例如.com .cn .hk 这种级别的服务器地址。 

dns当然也是有本地缓存的，当访问URL的时候，系统会默认去访问本地的dns缓存，当然有一个失效时间，如果没有任何设置的话，远程服务器的URL和ip进行了更改，本地的缓存必须等到失效才能进行更新。

在访问本地dns缓存的时候会从`www.example.com`  => `example.com` => `.com` => `.` 的次序去查找本地的缓存，假如，`www.example.com` 是没有的，那么查询到`example.com`是有的，它就会从直接寻找到这个缓存里的服务器地址，然后从这个地址里去远程查找到`www.example.com` 最终要找的ip或者其它形式的地址信息。所以说dns服务器也是分层次的，按照每层的方式去查找，并且，每一层的dns地址都是有缓存的机制，并且如果更改必须等待失效

因为dns是多分层的查找机制，每一层都是缓存，如果想查找的URL，在本地没有一层有缓存，那么就注定了响应时间非常长，这是第一个缺点，解决方法就是配置一个预获取地址的一个标签`<link rel="dns-prefetch" href="//cdn.eed.com">`

第二个缺点是，非常容易被攻击，也就是所谓的dns劫持，比如说你要查找 www.github.com 在你的本机存有 `.com`服务器的缓存地址，然后就没有了，那么你把这个缓存里面的服务器的地址取出来，比如说是89.87.43.1 然后你访问了这个地址，从里面开始查找 github.com 然后返回回来一个ip，这个时候你再访问这个ip，比如说是98.34.123.43 然后你再这个服务器中查找 `www.github.com`的地址ip，这个时候你才会真正的找到真实的ip地址，我想说的被攻击，比如说你本地存放的.com 地址就是假的，然后你返回给你的ip就不是真的github.com 它可能是伪造的，然后你访问了这个地址，那么这个地址呢就会去访问真的github.com,不过它会在真的内容里加上一些html比如广告，这个时候你自己也访问到了真实的github.com了，诶只不过你访问的内容被dns服务商给加了点广告。这是最友好的劫持了。

解决dns其实也简单，比如说你不靠系统去获取所谓本机的缓存dns服务器的地址，你自己用程序主动获取一个权威的，而且使用https去获取不使用传统的udp，这个时候返回的结果就是正确的，然后你再一层一层的这么干，直到查找到真实的ip或者其它形式的地址。

## 传输链路
从http1.0时代，到http2.0乃至3.0的时代，http协议一直在发展。

在1.0时代，系统无法处理大量的短链接，然后奇艺巧思就是合并请求，好处呢就是大量的短链接变成了一个长链接，可以加快浏览器的效率，坏处就是客户端的资源必须一次性加载，比如一大批图片不能一个一个的出现，必须同时出现，非常影响观感，到了2.0时代，把传输的最小单位从一个请求改为了frame 帧，并且给每一个frame都分配一个id，并且将这些frame用流的形式去传递，这个时候只需要建立一个长链接，只需要识别一个流中的frame即可，frame可以随意不按顺序传递，并且还不用合并请求，当然这个2.0时代对于短链接是友好了，但是对于长链接还是一样的毛病，如果长链接的内容过大一样会影响客户端，原因是当传递的长链接其中某个包出现了问题时，系统会重新传递，而且是全部的内容。这跟tcp协议的重传机制有关，所以3.0时代就改为了udp的传输协议，然后通过http应用层去做数据的识别。
## 内容分发网络 cdn
cdn在多级的分流系统中的作用也非常大，举一个非常简单的例子，b站的视频，从上传到公司的服务器开始，系统就开始着手去布置cdn，有了cdn，即便是你的那个访问出了问题，也跟公司系统里面的视频没有半毛钱关系。

cdn的作用极大，因为大量的资源通过内容分发的方法去让就近获取，极大的减轻了公司后段服务器的压力，注意是极大。

- 路由解析

    - 用户首次去访问URL，经过loop的发现本地dns并没有任何信息
    - 本地dns服务开始去访问dns服务器，并且逐渐找到了这个URL的最终的ip地址
    - 这个ip地址返回一个CNAME信息给用户的dns服务
    - 本地的缓存就记住了这个CNAME
    - 然后本地dns服务去访问了这个CNAME 的URL，查询到这个URL的ip地址
    - 这个ip地址其实是cdn厂商给的dns服务器，dns服务器经过负载均衡的方法返回一个ip地址给客户的dns服务
    - dns服务返回ip给客户端
    - 客户端拿到了这个ip，去访问ip，这个ip是cdn的服务器
    - cdn服务器去访问你的服务器，服务器返回结果给cdn，cdn返回结果给用户，并且进行缓存
    - 以后再访问URL就会访问cdn网络的缓存了。

- 内容分发

    - 主动分发 

            就是服务器主动推送到cdn网络上，更甚者直接主动推送到终端上，当然了这些都是非常常用的资源

    - 被动分发
    
            就是客户访问内容的时候，cdn发现自己还没有，就去主动向服务提供商获取资源，然后再把资源返回给用户
    
    通常来说内容的实效分为超时实效和人工时效

- cdn应用

    - 加速静态资源
        
            一般来说部署的css ，js html等静态资源，视频网站的视频，都是使用cdn来加速用户的访问的

    - 安全防御

            只要不被泄漏真实服务器的ip就不会被真正的攻击，例如ddos的攻击就是只会攻击cdn服务器并不会对真实数据造成影响

    - 协议升级


            例如你的服务部署的是http，那么cdn提供https

    - 状态缓存

            例如301 302 可以让访问cdn时不访问源服务器地址，cdn直接缓存了这个地址，例如404界面或者301的目标界面

    - 修改资源

            例如源地址不支持跨域请求或者不支持压缩，那么cdn就可以支持这些技术

    - 访问控制

            源地址没有过滤机制，cdn就可以去实现一个过滤机制来防止盗链，成立一个黑名单机制

    - 注入功能

            cdn可以不修改源内容的情况下去加入一下其它的功能

## 负载均衡
从dns到cdn都是负载均衡的实现者，下面只从网络协议的维度去讨论负载均衡

- 数据链路层负载均衡
        
        由于链路层的Mac地址具有唯一性，负载均衡器将请求的Mac地址转发到不同的机器上即可，不过由于ip层看不到，所以必须将负载均衡器的虚拟ip和服务器的虚拟ip设置一致，不然客户端就不可能收到响应

- 网络层负载均衡

        网络层会记录请求的ip和目标ip，那么我们可以将负载均衡器的虚拟ip和源服务器的ip设置为一样，然后将请求ip在转发的时候从负载均衡器的ip直接修改为客户端的ip这样响应的时候就可以直接从源服务器和客户端直接沟通

- 应用层负载均衡

        就是所谓的反向代理模式

- 均衡策略与实现

        - 轮询
        - 权重轮询
        - 随机
        - 权重随机
        - 一致性哈希
        - 根据响应速度进行均衡，就是提前给目标发送一个ping，看哪个服务器ping小就往谁那里去发送
        - 最小连接数均衡 

## 服务端缓存
