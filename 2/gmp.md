# go语言运行时的调度器
进程是操作系统资源共享的基本单位，线程是操作系统调度的最基本单位，go决定使用协程作为基本的执行单元，常见的有多进程，多线程，多进程的上下文切换耗时太长，多线程虽然有所改善，但是仍然比较长，go选协程可以大幅度降低资源在各个执行单元中切换的时间

go语言的调度模型在各个时期是有不同的模型的，那么我们先了解一下它的演变过程。

- 单线程调度
    
    在这个版本里，runtime代码还是用c写的，这个单线程调度就是同时仅仅支持一个g来执行，每次先上锁，g执行，执行完释放锁再去执行下一个g
- 多线程调度

    这个时候程序内就存在多个同时运行的线程，所以引入了多线程调度器，并且引入了 GOMAXPROCS 这个可以控制最大并发的设置。这个阶段容易产生全局锁颗粒度大，可执行线程之间经常交换g造成时间上的浪费等问题
- 任务窃取调度

    正式引入G:M:P 模型，工作窃取的意思就是目前这个p下面没有正在运行的g，那么就从其它的p中窃取


    下面是p这个调度器的结构体，可以看出，它拥有了两个g参数，一个是队列，一个是g0变量，其中还包括了一个m，所以它的调度方式就是将队列中的队头拉到m中去执行，每一个m对应一个p，每一个m对应了cpu中的一个线程（比如4核8线程），这个线程可以成为一个内核了，最起码操作系统是这么认为的。
    ```c
    struct P {
	Lock;

	uint32	status;
	P*	link;
	uint32	tick;
	M*	m;
	MCache*	mcache;

	G**	runq;
	int32	runqhead;
	int32	runqtail;
	int32	runqsize;

	G*	gfree;
	int32	gfreecnt;
    };

    ```
    此版本的的p没有可以停止g执行的权利，意思是，只有让g主动让出cpu的执行才可以，p没有那个能力去干预。
- 抢占式调度

    在这个版本中，p拥有了抢占能力，可以主动去干预g的执行问题。go会在stop the world的时候发现运行时间超过10ms的g，让它让出cpu执行。

    目前的抢占只发生在垃圾回收阶段。
- 非均匀内存访问调度器

    目前是为了增加数据的局部性减少数据的全局性，因为全局就意味着锁的颗粒度不够小，各种资源统一调度会有资源利用率低等问题。
## G:M:P 模型   
### G:M:P的数据结构
|G|M|P|
|:---:|:---:|:---:|
|对应了go内部的最基本的可执行单元|直接对应操作系统的线程|对应了本地调度器| 

G:
```go
```
M:
```go
```
P:
```go
```
### 调度器的启动
### 创建goroutine
### 调度循环
### 触发调度
### 线程管理
## runtime.gosched()基于阻塞的协程调度

Gosched 允许其他goroutine运行,它不会挂起当前的goroutine,因此会自动恢复执行。