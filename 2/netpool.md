# net pool  网络轮询器

io的步骤：

- 等待网络数据到达网卡(读就绪)/等待网卡可写(写就绪) –> 读取/写入到内核缓冲区
- 从内核缓冲区复制数据 –> 用户空间(读)/从用户空间复制数据 -> 内核缓冲区(写)

io模型分为以下几种
- 阻塞式

    当系统调用read或者write的时候，系统从用户态切换为内核态，内核会检查文件描述符的状态是否可读，如果可读就读取数据，并将数据复制给用户，并切换为用户态，反之，内核将一直阻塞，直到文件描述符可读。
- 非阻塞式
    
    非阻塞式，系统会立刻回返回文件描述符的返回值，不会再阻塞等待数据，但是返回值可能是error或者是可读转台，如果是error就证明并没有准备好数据，这个时候需要系统不断的轮询，当可读以后，系统就可以读取系统缓冲区的数据，并将数据复制给用户，非阻塞式，可以在系统轮询的间隙去做另外的工作，提高了系统的利用率。
- 信号驱动

    当fd上的拥有可以io的时候，系统会给程序发送信号，告知这个套接字可用了，还是需要程序去主动阻塞去读取信息
- 异步模型

    当程序去发起io的时候，程序会立刻返回，然后系统内核去监听fd，这个时候跟信号驱动的区别就来了，当io可用的时候，系统会直接执行这个io，并取得数据放置到缓冲区，程序可以直接取得这个数据，相当于系统帮你做了两件事，一是监控这个套接字，二是主动帮你搞定io的数据
- io多路复用

    io多路复用同样也是同步模型，其实除了异步模型都是同步模型，这个io多路复用又分select，poll和epool，这个模型的原理是这样的，很多fd放置到系统的fd红黑树中，select和poll会去轮询这棵树，只要发现上面有可用的套接字，那么程序就会主动去轮询查看到底是哪个可用的套接字，找到以后，程序就会把这个套接字主动阻塞的进行接收数据，所以select和poll都是需要轮询这棵树的，并且只能发现可以io的fd，并不能获取具体的id，select与poll的最大缺点是每次调用时都需要传入所有要监听的fd集合，内核再遍历这个传入的fd集合，然后再有多线程去获取缓存区的数据，当并发量大时候，用户态与内核态之间的数据拷贝以及内核轮询fd又要浪费一波系统资源，epoll改变了这么几件事儿，首先它是按照callback的形式存在的，当然也是立刻返回不会阻塞，当callback中事件成立了，那么就会发起一个真的io，所以epoll也是一种信号驱动，epoll比信号驱动更好的地方在于信号驱动是每此有一个信号，或者一批信号，系统是发信号通知，这个时候有一个信号队列，有可能队列会溢出，而callback这种机制就不存在，只要事件得到应答以后，就会直接back回来做真正的io，并不会存在一个信号队列。

### 水平触发和边缘触发

水平触发的意思是是说只要满足条件就会一直触发事件，举个例子，某个socket传过来100k数据，这个时候水平触发和边缘触发都会发送ready的信号，假设程序一次读了50kb的数据，那么水平触发就会不断的告诉你，你还有数据呢，没读完，赶紧再来读啊，所以这个过程就是轮询的，一直再给你发事件，通知你，你还有东西，但是边缘触发不是，你读了50k的对吧，你没读完对吧，我不会再通知你了，你耗子尾汁，爱咋咋地，直到再次又有信号通知来了，说又有某个socket准备好了可以进行io动作了，这个时候才会再次通知说可以读了，那么你上次的数据才会被读取，但是这样一个socket就是不完整了，那么就需要当我们是边缘触发的时候一次读完整，别拉下，直到读到说你读完的信号发出后，再停止读取，这样就OK了，所以说select和poll需要不断的轮询去查看fd的状态，以及查看缓存区的数据状态，因为前者是为了观察fd的状态，后面的轮询是为了查看缓存区的数据是否读干净，为什么epoll的速度比poll的高呢，就是因为epoll的边缘触发就发出一次事件，但是你的poll需要一直发事件，那么你的这个callback就会比epoll的多很多次，那么肯定影响速度啊。

- poll【仅支持水平触发】
- select【仅支持水平触发】
- epoll【支持水平触发和边缘触发】
- 信号驱动io模型【支持边缘触发】
## 设计原理
不同的操作系统底层的模型是不一样的，都要实现以下方法：

```go
func netpollinit()
func netpollopen(fd uintptr, pd *pollDesc) int32
func netpoll(delta int64) gList
func netpollBreak()
func netpollIsPollDescriptor(fd uintptr) bool
```

go语言将fd句柄加入内核中的一个红黑树中，这个时候是使用的callback模式，当事件被触发后，就会把这个已经ready的socket的fd代表的socket发送到一个list中，表示这些已经ready，

这个时候不是已经获取到这么一个列表的嘛，我们可以看到上面那个过程就是标准的Linux的epoll的io多路复用的过程。因为我们已经获取到了这些已经OK的fd。

在go里每一个fd就会对应一个g，那么当这些g对应的fd没有ready的时候这些g是阻塞的，当这个列表中fd对应的g发现已经准备好的时候，就会去获取放置在缓存区的数据。

下面这两个场景go就是使用的上述描述的io多路复用的方式进行运行的

- io.rader/writer unix 
- net/http 基于goroutine的http服务器