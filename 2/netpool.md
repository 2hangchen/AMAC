# net pool  网络轮询器
io模型分为以下几种
- 阻塞式

    当系统调用read或者write的时候，系统从用户态切换为内核态，内核会检查文件描述符的状态是否可读，如果可读就读取数据，并将数据复制给用户，并切换为用户态，反之，内核将一直阻塞，直到文件描述符可读。
- 非阻塞式
    
    非阻塞式，系统会立刻回返回文件描述符的返回值，不会再阻塞等待数据，但是返回值可能是error或者是可读转台，如果是error就证明并没有准备好数据，这个时候需要系统不断的轮询，当可读以后，系统就可以读取系统缓冲区的数据，并将数据复制给用户，非阻塞式，可以在系统轮询的间隙去做另外的工作，提高了系统的利用率。
- 信号驱动

    当fd上的拥有可以io的时候，系统会给程序发送信号，告知这个套接字可用了，还是需要程序去主动阻塞去读取信息
- 异步模型

    当程序去发起io的时候，程序会立刻返回，然后系统内核去监听fd，这个时候跟信号驱动的区别就来了，当io可用的时候，系统会直接执行这个io，并取得数据放置到缓冲区，程序可以直接取得这个数据，相当于系统帮你做了两件事，一是监控这个套接字，二是主动帮你搞定io的数据
- io多路复用

    io多路复用同样也是同步模型，其实除了异步模型都是同步模型，这个io多路复用又分select，poll和epool，这个模型的原理是这样的，很多fd放置到系统的fd红黑树中，select和poll会去轮询这棵树，只要发现上面有可用的套接字，那么程序就会主动去轮询查看到底是哪个可用的套接字，找到以后，程序就会把这个套接字主动阻塞的进行接收数据，所以select和poll都是需要轮询这棵树的，并且只能发现可以io的fd，并不能获取具体的id，程序不得不在此遍历去寻找到底是哪几个可以，然后再有多线程去获取io的数据，并且将数据放置到一个队列中，程序再去获取这些数据，这个时候程序从系统内核中获取的数据还是需要复制才可以的，epoll改变了这么几件事儿，首先它是按照callback的形式存在的，当然也是立刻返回不会阻塞，当callback中事件成立了，那么就会发起一个真的io，这个时候也不会存在从系统中的数据再复制一次到程序中这种事情，epoll是直接共享数据，所以epoll也是一种信号驱动，epoll比信号驱动更好的地方在于信号驱动是每此有一个信号，或者一批信号，系统是发信号通知，这个时候有一个信号队列，有可能队列会溢出，而callback这种机制就不存在，只要事件得到应答以后，就会直接back回来做真正的io，并不会存在一个信号队列。

### 水平触发和边缘触发

水平触发的意思是是说只要满足条件就会一直触发事件，举个例子，某个socket传过来100k数据，这个时候水平触发和边缘触发都会发送ready的信号，假设程序一次读了50kb的数据，那么水平触发就会不断的告诉你，你还有数据呢，没读完，赶紧再来读啊，所以这个过程就是轮询的，一直再给你发事件，通知你，你还有东西，但是边缘触发不是，你读了50k的对吧，你没读完对吧，我不会再通知你了，你耗子尾汁，爱咋咋地，直到再次又有信号通知来了，说又有某个socket准备好了可以进行io动作了，这个时候才会再次通知说可以读了，那么你上次的数据才会被读取，但是这样一个socket就是不完整了，那么就需要当我们是边缘触发的时候一次读完整，别拉下，直到读到说你读完的信号发出后，再停止读取，这样就OK了，所以说select和poll需要不断的轮询去查看fd的状态，以及查看缓存区的数据状态，因为前者是为了观察fd的状态，后面的轮询是为了查看缓存区的数据是否读干净，为什么epoll的速度比poll的高呢，就是因为epoll的边缘触发就发出一次事件，但是你的poll需要一直发事件，那么你的这个callback就会比epoll的多很多次，那么肯定影响速度啊。

- poll【仅支持水平触发】
- select【仅支持水平触发】
- epoll【支持水平触发和边缘触发】
- 信号驱动io模型【支持边缘触发】
## 设计原理
不同的操作系统底层的模型是不一样的，都要实现以下方法：

```go
func netpollinit()
func netpollopen(fd uintptr, pd *pollDesc) int32
func netpoll(delta int64) gList
func netpollBreak()
func netpollIsPollDescriptor(fd uintptr) bool
```
### go语言的网络io模型
## 数据结构
## 多路复用
## io.rader/writer unix 文件哲学
## net/http 基于goroutine的http服务器